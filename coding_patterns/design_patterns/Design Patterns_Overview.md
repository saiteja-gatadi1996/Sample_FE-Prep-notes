### 1. Module Pattern

It's a great way to split a larger codebase into multiple smaller, reusable pieces. It also promotes code encapsulation.

### 2. Prototype Pattern

When we want to share properties among many objects of the same type, we can use the Prototype pattern.

### 3. Proxy Pattern

It uses a Proxy intercept and control interactions to target objects. With this we don't want to interact with this object directly.

### 4. Observer Pattern

It uses observables to notify subscribers when an event occurs. Here we have an, observable object to notify and Subscriber to listen.

### 5. Factory Pattern

The factory pattern is useful when we have to create multiple objects that share the same properties.

### 6. Singleton Pattern

It restricts the instantiation of certain classes to one single instance, making it unmodifiable.

### 7. Mediator Pattern

This makes it possible for components to interact with each other through a central point, and can through a mediator.

### 8. Flyweight Pattern

Flyweight is a useful way to conserve memory when weâ€™re creating a large number of similar objects.

### 9. Mixin Pattern

A mixin is an object that we can use in order to add reusable functionality to another object or class, without using inheritance.

---

![alt text](/coding_patterns/design_patterns/a_imagesUsed/DesignPatterns.webp)

According to this map, there are three main types of design patterns.

- **Creational Design Patterns** focus on the process of **`object/class`** creation.
- **Structural Design Patterns** are concerned with the **`composition`** of classes or objects.
- **Behavioral Design Patterns** focus on the **`interaction`** and **`communication`** between objects and classes.

